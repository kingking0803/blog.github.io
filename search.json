[{"title":"CAS单点登录","url":"%2Fblog.github.io%2F2018%2F04%2F05%2Fcas%2F","content":"## 环境\n1、Tomcat8\n2、JDK8\n3、CAS Server：4.0.0（这个版本较老，可以用新的版本）\n4、CAS Client：3.1.10（用maven引入）\n5、Spring Boot项目\n\n## 创建证书\n1、用jdk自带的keytool生成证书：\n>命令：keytool -genkey -alias wsria -keyalg RSA -keystore d:/keys/wsriakey\n\n在输入完密码后提示输入域名是我输入的是 sso.wsria.com，其实这个域名是不存在的，但是我为了演示所以虚拟了这个域名，技巧在于修改C:\\Windows\\System32\\drivers\\etc\\hosts，添加内容如下：\n\n127.0.0.1 sso.wsria.com\n\n这样在访问sso.wsria.com的时候其实是访问的127.0.0.1也就是本机\n\n**严重提醒**：提示输入域名的时候**不能**输入**IP地址**\n\n## 导出证书\n>命令：D:\\keys>keytool -export -file d:/keys/wsria.crt -alias wsria -keystore d:/keys/wsriakey\n\n## 为客户端的JVM导入证书\n\n>命令：keytool -import -keystore D:\\tools\\jdk\\1.6\\jdk1.6.0_20\\jre\\lib\\security\\cacerts -file D:/keys/wsria.crt -alias wsria\n\n**特别说明**:输入的keystore密码并不是刚才设置的证书密码，是默认密码changeit\n\n## 应用证书到Web服务器-Tomcat\n\n打开tomcat目录的conf/server.xml文件，开启如下注释，并设置keystoreFile、keystorePass修改结果如下：\n> &lt;Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\"  maxThreads=\"150\" scheme=\"https\" secure=\"true\"  clientAuth=\"false\" sslProtocol=\"TLS\"  keystoreFile=\"D:/keys/wsriakey\" keystorePass=\"wsria.com\"  />\n\n参数说明：\n\n*   keystoreFile：在第一步创建的key存放位置\n*   keystorePass：创建证书时的密码\n\n好了，到此Tomcat的SSL启用完成，现在你可以启动tomcat试一下了，例如本教程输入地址：https://sso.wsria.com:8443/\n默认的登录账号为casuser密码为Mellon\n\n## 为CAS服务器设置数据库连接登录\n\n在CAS服务项目中的deployerConfigContext.xml中找id为primaryAuthenticationHandler的bean，将这个bean替换\n>&lt;bean id=\"primaryAuthenticationHandler\" class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationWithSaltHandler\">  \n        &lt;property name=\"dataSource\" ref=\"dataSource\" />  \n        &lt;property name=\"sql\" value=\"select password from sys_user where username=?\" />  \n        &lt;property name=\"passwordSaltEncoder\" ref=\"MD5PasswordEncoder\"/>  \n    &lt;/bean>\n\n配置对应的数据库连接和密码校验类\n>&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">  \n        &lt;property name=\"driverClassName\">&lt;value>com.mysql.jdbc.Driver&lt;/value>&lt;/property>  \n        &lt;property name=\"url\">&lt;value>jdbc:mysql://localhost:3306/lenos&lt;/value>&lt;/property>  \n        &lt;property name=\"username\">&lt;value>root&lt;/value>&lt;/property>  \n        &lt;property name=\"password\">&lt;value>asdf1234&lt;/value>&lt;/property>  \n    &lt;/bean>     \n    &lt;bean id=\"MD5PasswordEncoder\" class=\"org.jasig.cas.authentication.handler.CustomPasswordEncoder\">    \n    &lt;/bean>\n\n其中CustomPasswordEncoder为自定义加密类，QueryDatabaseAuthenticationWithSaltHandler也是自定义的类，\n因为客户端系统的密码校验功能可能和CAS默认校验方式不同\n\n## 为客户端系统依赖CAS\n\nmaven加入如下依赖\n>&lt;dependency>\n   &lt;groupId>org.jasig.cas&lt;/groupId>\n   &lt;version>3.1.10&lt;/version>\n   &lt;artifactId>cas-client-core&lt;/artifactId>\n&lt;/dependency>\n\napplication.yml配置信息\n>spring:\n    cas:\n     sign-out-filters: /logout\n      auth-filters: /*\n      validate-filters: /*\n      request-wrapper-filters: /*\n      assertion-filters: /*\n      cas-server-login-url: https://sso.wsria.com:8443/cas/login\n      cas-server-url-prefix: https://sso.wsria.com:8443/cas\n      redirect-after-validation: true\n      use-session: true\n      server-name: http://localhost:8087\n      validation-type: CAS\n\nSpringCasAutoConfig.java用于获取配置信息\n>@Component @ConfigurationProperties(prefix = \"spring.cas\")\npublic class SpringCasAutoConfig {\n    static final String separator = \",\";\n    private String validateFilters;\n    private String signOutFilters;\n    private String authFilters;\n    private String assertionFilters;\n    private String requestWrapperFilters;\n    private String casServerUrlPrefix;\n    private String casServerLoginUrl;\n    private String serverName;\n    private boolean useSession = true;\n    private boolean redirectAfterValidation = true;\n    public List<String> getValidateFilters() {\n        return Arrays.asList(validateFilters.split(separator));\n    }\n    public void setValidateFilters(String validateFilters) {\n        this.validateFilters = validateFilters;\n    }\n    public List<String> getSignOutFilters() {\n        return Arrays.asList(signOutFilters.split(separator));\n    }\n    public void setSignOutFilters(String signOutFilters) {\n        this.signOutFilters = signOutFilters;\n    }\n    public List<String> getAuthFilters() {\n        return Arrays.asList(authFilters.split(separator));\n    }\n    public void setAuthFilters(String authFilters) {\n        this.authFilters = authFilters;\n    }\n    public List<String> getAssertionFilters() {\n        return Arrays.asList(assertionFilters.split(separator));\n    }\n    public void setAssertionFilters(String assertionFilters) {\n        this.assertionFilters = assertionFilters;\n    }\n    public List<String> getRequestWrapperFilters() {\n        return Arrays.asList(requestWrapperFilters.split(separator));\n    }\n    public void setRequestWrapperFilters(String requestWrapperFilters) {\n        this.requestWrapperFilters = requestWrapperFilters;\n    }\n    public String getCasServerUrlPrefix() {\n        return casServerUrlPrefix;\n    }\n    public void setCasServerUrlPrefix(String casServerUrlPrefix) {\n        this.casServerUrlPrefix = casServerUrlPrefix;\n    }\n    public String getCasServerLoginUrl() {\n        return casServerLoginUrl;\n    }\n    public void setCasServerLoginUrl(String casServerLoginUrl) {\n        this.casServerLoginUrl = casServerLoginUrl;\n    }\n    public String getServerName() {\n        return serverName;\n    }\n    public void setServerName(String serverName) {\n        this.serverName = serverName;\n    }\n    public boolean isRedirectAfterValidation() {\n        return redirectAfterValidation;\n    }\n    public void setRedirectAfterValidation(boolean redirectAfterValidation) {\n        this.redirectAfterValidation = redirectAfterValidation;\n    }\n    public boolean isUseSession() {\n        return useSession;\n    }\n    public void setUseSession(boolean useSession) {\n        this.useSession = useSession;\n    }\n}\n\n实现单点登出功能\n>@Configuration public class CasConfig {\n    @Autowired\n  private SpringCasAutoConfig springCasAutoConfig;\n    private static boolean casEnabled = true;\n    public CasConfig(){\n    }\n    @Bean\n  public SpringCasAutoConfig getSpringCasAutoconfig(){\n        return new SpringCasAutoConfig();\n    }\n    @Bean\n  public ServletListenerRegistrationBean<SingleSignOutHttpSessionListener> singleSignOutHttpSessionListener(){\n        ServletListenerRegistrationBean<SingleSignOutHttpSessionListener> listener = new ServletListenerRegistrationBean<SingleSignOutHttpSessionListener>();\n        listener.setEnabled(casEnabled);\n        listener.setListener(new SingleSignOutHttpSessionListener());\n        listener.setOrder(1);\n        return listener;\n    }\n@Bean\n  public FilterRegistrationBean logOutFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        LogoutFilter logoutFilter = new LogoutFilter(springCasAutoConfig.getCasServerUrlPrefix() + \"/logout?service=\" + springCasAutoConfig.getServerName(),new SecurityContextLogoutHandler());\n        filterRegistration.setFilter(logoutFilter);\n        filterRegistration.setEnabled(casEnabled);\n        if(springCasAutoConfig.getSignOutFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getSignOutFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/logout\");\n        filterRegistration.addInitParameter(\"casServerUrlPrefix\", springCasAutoConfig.getCasServerUrlPrefix());\n        filterRegistration.addInitParameter(\"serverName\", springCasAutoConfig.getServerName());\n        filterRegistration.setOrder(2);\n        return filterRegistration;\n    }\n@Bean\npublic FilterRegistrationBean singleSignOutFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        filterRegistration.setFilter(new SingleSignOutFilter());\n        filterRegistration.setEnabled(casEnabled);\n        if(springCasAutoConfig.getSignOutFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getSignOutFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/*\");\n        filterRegistration.addInitParameter(\"casServerUrlPrefix\", springCasAutoConfig.getCasServerUrlPrefix());\n        filterRegistration.addInitParameter(\"serverName\", springCasAutoConfig.getServerName());\n        filterRegistration.setOrder(3);\n        return filterRegistration;\n    }\n @Bean\n  public FilterRegistrationBean authenticationFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        filterRegistration.setFilter(new AuthenticationFilter());\n        filterRegistration.setEnabled(casEnabled);\n        if(springCasAutoConfig.getAuthFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getAuthFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/*\");\n        //casServerLoginUrl:cas服务的登陆url\n  filterRegistration.addInitParameter(\"casServerLoginUrl\", springCasAutoConfig.getCasServerLoginUrl());\n        //本项目登录ip+port\n  filterRegistration.addInitParameter(\"serverName\", springCasAutoConfig.getServerName());\n        filterRegistration.addInitParameter(\"useSession\", springCasAutoConfig.isUseSession()?\"true\":\"false\");\n        filterRegistration.addInitParameter(\"redirectAfterValidation\", springCasAutoConfig.isRedirectAfterValidation()?\"true\":\"false\");\n        filterRegistration.setOrder(4);\n        return filterRegistration;\n    }\n@Bean\npublic FilterRegistrationBean cas20ProxyReceivingTicketValidationFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        Cas20ProxyReceivingTicketValidationFilter cas20ProxyReceivingTicketValidationFilter = new Cas20ProxyReceivingTicketValidationFilter();\n        cas20ProxyReceivingTicketValidationFilter.setServerName(springCasAutoConfig.getServerName());\n        filterRegistration.setFilter(cas20ProxyReceivingTicketValidationFilter);\n        filterRegistration.setEnabled(casEnabled);\n        if(springCasAutoConfig.getValidateFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getValidateFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/*\");\n        filterRegistration.addInitParameter(\"casServerUrlPrefix\", springCasAutoConfig.getCasServerUrlPrefix());\n        filterRegistration.addInitParameter(\"serverName\", springCasAutoConfig.getServerName());\n        filterRegistration.setOrder(5);\n        return filterRegistration;\n    }\n@Bean\npublic FilterRegistrationBean httpServletRequestWrapperFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        filterRegistration.setFilter(new HttpServletRequestWrapperFilter());\n        filterRegistration.setEnabled(true);\n        if(springCasAutoConfig.getRequestWrapperFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getRequestWrapperFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/*\");\n        filterRegistration.setOrder(6);\n        return filterRegistration;\n    }\n@Bean\npublic FilterRegistrationBean assertionThreadLocalFilter() {\n        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();\n        filterRegistration.setFilter(new AssertionThreadLocalFilter());\n        filterRegistration.setEnabled(true);\n        if(springCasAutoConfig.getAssertionFilters().size()>0)\n            filterRegistration.setUrlPatterns(springCasAutoConfig.getAssertionFilters());\n        else\n  filterRegistration.addUrlPatterns(\"/*\");\n        filterRegistration.setOrder(7);\n        return filterRegistration;\n    }\n}\n\n现在登录CAS会默认跳转到CAS登录界面，然后输入部署系统的账号密码就会登录到系统界面，这里出现一个问题是，登录后出来的还是客户端的登录界面，现在希望登录后跳转到客户端系统的主界面。我这边的操作是将CAS服务端的登录账号和密码返回给客户端，然后做判断是否正确然后直接跳转到主界面\n修改deployerConfigContext.xml的id为attributeRepository的bean：\n>&lt;bean id=\"attributeRepository\"  \n        class=\"org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao\">  \n        &lt;constructor-arg index=\"0\" ref=\"dataSource\"/>  \n        &lt;constructor-arg index=\"1\" value=\"select * from sys_user where {0}\"/>  \n        &lt;property name=\"queryAttributeMapping\">  \n            &lt;map>  \n                &lt;entry key=\"username\" value=\"username\"/>&lt;!--key与登录页面一致，value对应数据库-->  \n            &lt;/map>  \n        &lt;/property>  \n        &lt;property name=\"resultAttributeMapping\">  \n            &lt;map>  \n                &lt;entry key=\"id\" value=\"id\"/>  \n                &lt;entry key=\"username\" value=\"username\"/>\n                &lt;entry key=\"password\" value=\"password\"/>\n            &lt;/map>  \n        &lt;/property>  \n    &lt;/bean>\n\n然后修改id为serviceRegistryDao的bean：\n>&lt;bean id=\"serviceRegistryDao\" class=\"org.jasig.cas.services.InMemoryServiceRegistryDaoImpl\">\n        &lt;property name=\"registeredServices\">\n            &lt;list>\n                &lt;bean class=\"org.jasig.cas.services.RegexRegisteredService\">  \n                        &lt;property name=\"id\" value=\"0\" />  \n                        &lt;property name=\"name\" value=\"HTTP and IMAP\" />  \n                        &lt;property name=\"description\" value=\"Allows HTTP(S) and IMAP(S) protocols\" />  \n                        &lt;property name=\"serviceId\" value=\"^(https?|imaps?)://.*\" />  \n                        &lt;property name=\"evaluationOrder\" value=\"10000001\" />  \n                        &lt;!-- ******* add start ******* -->  \n                        &lt;property name=\"allowedAttributes\">  \n                            &lt;list>  \n                                &lt;value>id&lt;/value>  \n                                &lt;value>username&lt;/value>\n                                &lt;value>password&lt;/value> \n                            &lt;/list>  \n                        &lt;/property>  \n                        &lt;!-- ******* add end ******* -->  \n                    &lt;/bean>\n            &lt;/list>\n        &lt;/property>\n    &lt;/bean>\n\n这时候就可以通过request.getUserPrincipal().getAttributes()获取上述传递的参数\n\n## 可能出现的问题\n编译环境：\nmaven3.2.1\njdk6\n使用mvn clean package -Dmaven.test.skip=true -Dcheckstyle.skip对项目进行编译。我在编译cas-server-core的时候出现过如下错误：\n1、 **[ERROR] Failed to execute goal com.mycila.maven-license-plugin:maven-license-plugin:1.9.0:check (default) on project cas-server: Resource C:\\xxx\\cas-server-4.0.0/src/licensing/header.txt not found in file system, classpath or URL: unknown protocol: c -> [Help 1]**\n解决方法：[cas导入maven缺少head.txt文件（ 密码: a4ag）](https://pan.baidu.com/s/1f9ee9zR30HhUTyxMFltZ3g)\n\n2、**Failed to execute goal com.mycila:license-maven-plugin:3.0:check (default) on project xxx: Some files do not have the expected license header -> [Help 1]**\n解决方法：输入命令mvn license:format\n"},{"title":"Dubbo分布式服务框架解析","url":"%2Fblog.github.io%2F2018%2F03%2F27%2Fdubbo%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%2F","content":"# 背景\nDubbo是Alibaba开源的分布式服务架构，它的框架以分层的方式进行架构，分为十层，各层均为单向依赖，分别是service服务层、config配置层、proxy服务代理层、registry注册中心层、cluster路由层、monitor监控层、protocol远程调用层、exchange信息交换层、transport网络传输层、serialize序列化层。整个服务模型可以简化为两大块，服务提供方（Provider）和服务消费方（Consumer）。\n\n# 架构\n\n![jg](/blog.github.io/img/jg.png)\n\n| 节点 | 角色说明 |\n|---|---|\n| Registry | 服务注册与发现的注册中心 |\n| Provider | 服务的提供方 |\n| Consumer | 服务的消费方 |\n| Monitor | 监控中心 |\n| Container | 运行容器 |\n\n## 调用关系\n运行服务容器，启动服务提供方\n服务提供方向注册中心注册服务\n启动服务消费方，向服务中心注册服务，并获取服务提供方列表\n服务提供方和消费方每分钟向监控中心发送服务调用次数和调用时间，监控中心进行统计\n\n## 特性\n连通性\n>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小\n监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示\n服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销\n服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销\n注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外\n注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者\n注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表\n注册中心和监控中心都是可选的，服务消费者可以直连服务提供者\n\n健状性\n>监控中心宕掉不影响使用，只是丢失部分采样数据\n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\n注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\n服务提供者无状态，任意一台宕掉后，不影响使用\n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n伸缩性\n>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心\n服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者\n\n升级性\n>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力\n\n# 搭建dubbo框架\n## 注册中心\nZookeeper是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用\n\n![zookeeper_tree](/blog.github.io/img/zookeeper_tree.png)\n\n### zookeeper支持以下功能\n当提供者出现断电等异常停机时，注册中心能自动删除提供者信息\n当注册中心重启时，能自动恢复注册数据，以及订阅请求\n当会话过期时，能自动恢复注册数据，以及订阅请求\n当设置 <dubbo:registry check=\"false\" /> 时，记录失败注册和订阅请求，后台定时重试\n可通过 <dubbo:registry username=\"admin\" password=\"1234\" /> 设置 zookeeper 登录信息\n可通过 <dubbo:registry group=\"dubbo\" /> 设置 zookeeper 的根节点，不设置将使用无根树\n支持 \\* 号通配符 ，可订阅服务的所有分组和所有版本的提供者\n\n## 服务提供方和消费方\n### 配置\n一般的web项目本地配置：\n\n![local](/blog.github.io/img/local.png)\n\ndubbo项目配置：\nprovider\n![remote_provider](/blog.github.io/img/remote_provider.png)\nconsumer\n![remote_consumer](/blog.github.io/img/remote_consumer.png)\n\n### Schema配置\n\n| schema | 说明 |\n|---|---|\n| dubbo:service | 服务提供者暴露服务配置 |\n| dubbo:reference | 服务消费者引用服务配置 |\n| dubbo:registry | 注册中心配置 |\n| dubbo:protocol | 服务提供者协议配置 |\n| dubbo:application | 服务消费者引用服务配置 |\n\n## 扩展实现\n\n例如要实现自定义的拦截器\n>扩展接口\ncom.alibaba.dubbo.rpc.Filter\n扩展配置\nMETA-INF/dubbo/com.alibaba.dubbo.rpc.Filter：\nxxx=com.xxx.XxxFilter\n调用自定义过滤器\n<dubbo:consumer filter=”xxx”/>\n\n## dobbo-admin\ndubbo-admin是服务管理平台，即对注册中心的服务进行管理，因此在启动dubbo-admin之前必须启动注册中心\n\n### 安装及运行\n1、下载dubbo-admin源码：[dubbo-admin](https://github.com/apache/incubator-dubbo-ops)\n\n2、到该目录下执行mvn clean package，进行编译\n\n3、将war包进行解压：jar xvf\n\n4、将文件夹拷贝到tomcat下运行\n\n5、成功后可看见如下界面\n\n![dubbo_admin](/blog.github.io/img/dubbo_admin.png)\n"},{"title":"Hello, Hexo","url":"%2Fblog.github.io%2F2018%2F03%2F26%2FHello-Hexo%2F","content":"欢迎使用hexo！"}]